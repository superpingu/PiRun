// Generated by CoffeeScript 1.11.1
(function() {
  var checkIP, dirname, i, ignorePatterns, ip, len, line, matchIgnore, name, path, pirunFile, pirunIgnore, pirunTime, program, request, root, shell, target, uploadFiles;

  shell = require('shelljs');

  request = require('sync-request');

  program = require('commander');

  path = require('path');

  root = '';

  name = '';

  target = '';

  program.version('0.0.1')["arguments"]('<piname> [dir] [target]').option('-f, --force', 'Force to reupload everything').action(function(piname, dir, tar) {
    name = piname;
    root = dir != null ? dir : '.';
    return target = tar != null ? tar : '';
  }).on('--help', function() {
    console.log('   <piname> : name of the Raspberry Pi on RPC or an IPv4 address');
    console.log('   [dir] : directory to upload and run, defaults to .');
    console.log('   [target] : the target of the Makefile to execute');
    return console.log('');
  });

  program.parse(process.argv);

  ip = '';

  checkIP = function(text) {
    var i, len, ref, splitIP, val;
    splitIP = text.split('.');
    if (splitIP.length !== 4) {
      return false;
    }
    for (i = 0, len = splitIP.length; i < len; i++) {
      val = splitIP[i];
      if (!((0 <= (ref = parseInt(val)) && ref < 256))) {
        return false;
      }
    }
    return true;
  };

  if (checkIP(name)) {
    ip = name;
  } else if (name.length === 0) {
    program.help();
  } else {
    ip = request('GET', "http://bonetti.io/rpc/api/ip/" + name).getBody().toString();
    if (ip === 'not found') {
      console.log("Raspberry Pi '" + name + "' not found");
      process.exit(-1);
    }
  }

  dirname = shell.pwd().split('/').pop();

  if (program.force) {
    pirunTime = 0;
    shell.exec("ssh pi@" + ip + " 'rm -rf /var/pirun/" + dirname + "'");
  } else {
    shell.config.silent = true;
    pirunFile = shell.ls('-l', path.join(root, ".pirun." + name));
    pirunTime = pirunFile.code !== 0 ? 0 : pirunFile[0].ctime;
  }

  pirunIgnore = shell.cat(path.join(root, ".pirunignore"));

  pirunIgnore = pirunIgnore.code !== 0 ? [] : pirunIgnore.split('\n');

  shell.config.silent = false;

  ignorePatterns = [/\.pirun\..*/g];

  for (i = 0, len = pirunIgnore.length; i < len; i++) {
    line = pirunIgnore[i];
    line = '^' + line.replace(/[.+?^${}()|[\]\\]/g, "\\$&").replace(/\*/g, '.*') + '$';
    if (line.trim().length > 0) {
      ignorePatterns.push(new RegExp(line));
    }
  }

  matchIgnore = function(filename) {
    var j, len1, pattern;
    for (j = 0, len1 = ignorePatterns.length; j < len1; j++) {
      pattern = ignorePatterns[j];
      if (filename.match(pattern)) {
        return true;
      }
    }
    return false;
  };

  uploadFiles = function(dir) {
    var didSomething, file, files, j, len1, output;
    files = shell.ls('-lA', path.join(root, dir));
    output = [];
    didSomething = false;
    for (j = 0, len1 = files.length; j < len1; j++) {
      file = files[j];
      if (!((file.mtime < pirunTime && !file.isDirectory()) || matchIgnore(path.join(dir, file.name)))) {
        if (file.isDirectory()) {
          didSomething |= uploadFiles(path.join(dir, file.name));
        } else {
          output.push(path.join(root, dir, file.name));
        }
      }
    }
    if (output.length > 0) {
      shell.exec("ssh pi@" + ip + " 'mkdir -p /var/pirun/" + (path.join(dirname, dir)) + "'");
      shell.exec("scp " + (output.join(' ')) + " pi@" + ip + ":/var/pirun/" + (path.join(dirname, dir)));
      return true;
    }
    return didSomething;
  };

  process.stdout.write('Uploading files ...');

  if (uploadFiles('')) {
    console.log(' OK\n');
  } else {
    console.log(' already up-to-date\n');
  }

  shell.touch(path.join(root, ".pirun." + name));

  shell.exec("ssh pi@" + ip + " 'make " + target + " -C /var/pirun/" + dirname + "'");

}).call(this);
